

######                                  设计模式                 

# [1.设计模式六大原则](https://www.cnblogs.com/Sam-2018/p/principle.html)    

1.**单一原则**（Single Responsibility Principle）：一个类或者一个方法只负责一项职责，尽量做到类的只有一个行为原因引起变化；

　　a、业务对象（BO business object）、业务逻辑（BL business logic）拆分；

**2.里氏替换原则**（LSP liskov substitution principle）：子类可以扩展父类的功能，但不能改变原有父类的功能；（本质其实就是c++的多态）

　　（目的：增强程序的健壮性）实际项目中，每个子类对应不同的业务含义，使父类作为参数，传递不同的子类完成不同的业务逻辑。

**3.依赖倒置原则（dependence inversion principle）**：面向接口编程；（通过接口作为参数实现应用场景）

　　抽象就是接口或者抽象类，细节就是实现类

　　含义：

　　　　上层模块不应该依赖下层模块，两者应依赖其抽象；

　　　　抽象不应该依赖细节，细节应该依赖抽象；

通俗点就是说变量或者传参数，尽量使用抽象类，或者接口；

【接口负责定义public属性和方法，并且申明与其他对象依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑】

**4.接口隔离（interface segregation principle）**：建立单一接口；（扩展为类也是一种接口，一切皆接口）

　　　定义：

　　　　a.客户端不应该依赖它不需要的接口；

　　　　b.类之间依赖关系应该建立在最小的接口上；

简单理解：复杂的接口，根据业务拆分成多个简单接口；（对于有些业务的拆分多看看适配器的应用）

　【接口的设计粒度越小，系统越灵活，但是灵活的同时结构复杂性提高，开发难度也会变大，维护性降低】　　　

**5.迪米特原则（law of demeter LOD）**：最少知道原则，尽量降低类与类之间的耦合；

一个对象应该对其他对象有最少的了解

　　

**6.开闭原则（open closed principle）：**用抽象构建架构，用实现扩展原则；（总纲）

**（solid稳定的 记忆首字母）**

# 2.设计模式的分类

总体来说设计模式分为三大类：

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

参考：[设计模式的三大分类及六大原则](https://blog.csdn.net/ttxs99989/article/details/81844135)



## 1.建造者模式

### **背景：**

当一个类的内部数据过于复杂的时候（通常是负责持有数据的类，比如Config、VO、PO、Entity...），要创建的话可能就需要了解这个类的内部结构，还有这些东西是怎么组织装配等一大坨乱七八糟的东西，这个时候就会增加学习成本而且会很混乱，这个时候就想啊想一种什么法子来管理一下这个类中的数据呢，怎么在创建的时候让它按部就班的来，并且代码可读性很好别让我看花了眼啊，我要的东西也能都很好设置进来，这就是Builder模式的应用场景，Builder模式可以将一个类的构建和表示进行分离。

### 介绍

#### 1.1什么是构建者模式

> **创建者模式又叫建造者模式，是将一个复杂的对象的构建与它的表示分离，使
>  得同样的构建过程可以创建不同的表示。**创建者模式隐藏了复杂对象的创建过程，它把复杂对象的创建过程加以抽象，通过子类继承或者重载的方式，动态的创建具有复合属性的对象。

#### 1.2适用场景：

- 隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果
- **多个部件都可以装配到一个对象中，但产生的运行结果不相同**
- 产品类非常复杂或者产品类因为调用顺序不同而产生不同作用
- 初始化一个对象时，参数过多，或者很多参数具有默认值
- Builder模式**不适合创建差异性很大的产品类**
   产品内部变化复杂，会导致需要定义很多具体建造者类实现变化，增加项目中类的数量，增加系统的理解难度和运行成本
- **需要生成的产品对象有复杂的内部结构，这些产品对象具备共性；**

#### 1.3 主要作用

> 在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。

- 用户只需要给出指定复杂对象的类型和内容；
- 建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来)

#### 1.4 解决的问题

- 方便用户创建复杂的对象（不需要知道实现过程）
- 代码复用性 & 封装性（将对象构建过程和细节进行封装 & 复用）

> 例子：造汽车 & 买汽车。
>
> 1. 工厂（建造者模式）：负责制造汽车（组装过>程和细节在工厂内）
>
> 2. 汽车购买者（用户）：你只需要说出你需要的>型号（对象的类型和内容），然后直接购买就可>>以使用了
>     （不需要知道汽车是怎么组装的（车轮、车门、>发动机、方向盘等等））
>
>    

###  模式原理

#### 2.1 UML类图 & 组成

![image-20201119104242084](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20201119104242084.png)

​                                                                               builder.png

#### 2.2模式讲解：

- 指挥者（Director）直接和客户（Client）进行需求沟通；

- 沟通后指挥者将客户创建产品的需求划分为各个部件的建造请求（Builder）；

- 将各个部件的建造请求委派到具体的建造者（ConcreteBuilder）；

- 各个具体建造者负责进行产品部件的构建；

- 最终构建成具体产品（Product）。  

    

  #### 2.3用 builder 模式创建共享单车为例子，示例代码：

  **一开始定义一个产品（属性？规格）和他的的制作流程，所有的产品都按这个流程(builder)来，不同的产品流程细节可能不一样，生产出的产品不一样。**

  

  用java来讲:

  一开始定义一个公共的抽象产品类，Product，这个对象包含了通用的属性。

  定义公用的父接口/抽象类？builder ,封装对Product的创建过程

  不同属性值的Product，使用不同的builder实现类去创建

  **产品的创建过程和表示分离，及对象的创建过程和内部属性获取分离。**

  用java来讲:

  不同属性值的Product，使用不同的builder实现类去创建，builder内部的过程调用方无需知道

  对象的相关属性的获取，使用Product的方法获取

  

  

  产品类：

```java

public class Bike { 

    private IFrame frame; 
    private ISeat seat; 
    private ITire tire; 
    
    public IFrame getFrame() { 
        return frame; 
    } 
    public void setFrame(IFrame frame) { 
        this.frame = frame; 
    } 
    public ISeat getSeat() { 
        return seat; 
    } 
    public void setSeat(ISeat seat) { 
        this.seat = seat; 
    } 
    public ITire getTire() { 
        return tire; 
    } 
    public void setTire(ITire tire) { 
        this.tire = tire; 
    } 
} 
```

Builder 类：

```java
// 抽象 builder 类 
public abstract class Builder { 
    abstract void buildFrame(); 
    abstract void buildSeat(); 
    abstract void buildTire(); 
    abstract Bike createBike(); 
} 
```

ConcreteBuilder 类 :

```java
// 具体 builder 类 
public class MobikeBuilder extends Builder{ 
    private Bike mBike = new Bike(); 
    @Override 
    void buildFrame() { 
        mBike.setFrame(new AlloyFrame()); 
    } 
    @Override 
    void buildSeat() { 
        mBike.setSeat(new DermisSeat()); 
    } 
    @Override 
    void buildTire() { 
        mBike.setTire(new SolidTire()); 
    } 
    @Override 
    Bike createBike() { 
        return mBike; 
    } 
} 

public class OfoBuilder extends Builder{ 
    private Bike mBike = new Bike(); 
    @Override 
    void buildFrame() { 
        mBike.setFrame(new CarbonFrame()); 
    } 
    @Override 
    void buildSeat() { 
        mBike.setSeat(new RubberSeat()); 
    } 
    @Override 
    void buildTire() { 
        mBike.setTire(new InflateTire()); 
    } 
    @Override 
    Bike createBike() { 
        return mBike; 
    } 
} 
```

指挥者类

```java
public class Director { 
    private Builder mBuilder = null; 
    public Director(Builder builder) { 
        mBuilder = builder; 
    } 
    public Bike construct() { 
        mBuilder.buildFrame(); 
        mBuilder.buildSeat(); 
        mBuilder.buildTire(); 
        return mBuilder.createBike(); 
    } 
}
```

客户端调用

```java
public class Click { 
    public static void main(String[] args) { 
        showBike(new OfoBuilder()); 
        showBike(new MobikeBuilder()); 
    } 
    private void showBike(Builder builder) {
        Director director = new Director(builder); 
        Bike bike = director.construct(); 
        bike.getFrame().frame(); 
        bike.getSeat().seat(); 
        bike.getTire().tire(); 
    } 
} 

```

上面示例是 Builder模式的常规用法，导演类 Director 在 Builder模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把Director和抽象建造者进行结合，示例代码：
链接：https://www.jianshu.com/p/3d1c9ffb0a28
改造后的抽象建造者：

```java
public abstract class NewBuilder { 
    abstract void buildFrame(); 
    abstract void buildSeat(); 
    abstract void buildTire(); 
    abstract Bike createBike(); 
    /** 
    * 把导演类中的construct()方法合并到抽象建造者类中 
    * 
    * @return 具体产品对象 
    */ 
    public Bike construct() { 
        this.buildFrame(); 
        this.buildSeat(); 
        this.buildTire(); 
        return this.createBike(); 
    } 
} 

```

这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果construct() 过于复杂，建议还是封装到 Director 中
 除了上面的用途外，还有另外一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用 builder模式进行重构，重构前示例代码：

```java
// 省略 getter 和 setter 方法 
public class Computer { 
    private String cpu; 
    private String screen; 
    private String memory; 
    private String mainboard; 
    public Computer(String cpu, String screen, String memory, String mainboard) { 
        this.cpu = cpu; 
        this.screen = screen; 
        this.memory = memory; 
        this.mainboard = mainboard; 
    } 
} 
public class NewComputer { 
    private String cpu; 
    private String screen; 
    private String memory; 
    private String mainboard; 
    public NewComputer() { 
        throw new RuntimeException(“can’t init”); 
    } 
    private NewComputer(Builder builder) { 
        cpu = builder.cpu; 
        screen = builder.screen; 
        memory = builder.memory; 
        mainboard = builder.mainboard; 
    } 
    public static final class Builder { 
        private String cpu; 
        private String screen; 
        private String memory; 
        private String mainboard; 
        
    public Builder() {} 
    
    public Builder cpu(String val) { 
        cpu = val; 
        return this; 
    } 
    public Builder screen(String val) { 
        screen = val; 
        return this; 
    } 
    public Builder memory(String val) { 
        memory = val; 
        return this; 
    } 
    public Builder mainboard(String val) { 
        mainboard = val; 
        return this; 
    } 
    public NewComputer build() {
        return new  NewComputer(this);} 
    } 
} 


```

客户端

```java

public class Click { 
    public static void main(String[] args) { 
        // 非 Builder 模式 
        Computer computer = new Computer(“cpu”, “screen”, “memory”, “mainboard”); 
        // Builder 模式 
        NewComputer newComputer = new NewComputer.Builder() 
        .cpu(“cpu”) 
        .screen(“screen”) 
        .memory(“memory”) 
        .mainboard(“mainboard”) 
        .build(); 
    } 
} 
```

## 2.桥接模式

### 背景

  设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：



​    • 第一种设计方案是为每一种形状都提供一套各种颜色的版本。



![img](https://img2018.cnblogs.com/blog/1475571/201901/1475571-20190112180432090-1967755010.png)

​    • 第二种设计方案是根据实际需要对形状和颜色进行组合。



![img](https://img2018.cnblogs.com/blog/1475571/201901/1475571-20190112180443952-1070829097.png)

  对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。



![img](https://img2018.cnblogs.com/blog/1475571/201901/1475571-20190112180505865-517948920.png)

### 模式定义

  桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。

### 模式结构



![img](https://img2018.cnblogs.com/blog/1475571/201901/1475571-20190112180526113-1204626425.png)

桥接模式包含如下角色：

  • **Abstraction**：抽象类

  • **RefinedAbstraction**：扩充抽象类

  • **Implementor**：实现类接口

  • **ConcreteImplementor**：具体实现类

### 模式分析

理解桥接模式，重点需要理解如何将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化。

  • 抽象化：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。

  • 实现化：针对抽象化给出的具体实现，就是实现化，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。

   • 脱耦：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。

典型的实现类接口代码：



```
1 public interface Implementor
2 {
3     public void operationImpl();
4 } 
```

 典型的抽象类代码：



[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1 public abstract class Abstraction
 2 {
 3     protected Implementor impl;
 4     
 5     public void setImpl(Implementor impl)
 6     {
 7         this.impl=impl;
 8     }
 9     
10     public abstract void operation();
11 } 
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 典型的扩充抽象类代码：



[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
1 public class RefinedAbstraction extends Abstraction
2 {
3     public void operation()
4     {
5         //代码
6         impl.operationImpl();
7         //代码
8     }
9 } 
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

### 实例与解析

**实例一：模拟毛笔**

  • 现需要提供大中小3种型号的画笔，能够绘制5种不同颜色，如果使用蜡笔，我们需要准备3*5=15支蜡笔，也就是说必须准备15个具体的蜡笔类。而如果使用毛笔的话，只需要3种型号的毛笔，外加5个颜料盒，用3+5=8个类就可以实现15支蜡笔的功能。本实例使用桥接模式来模拟毛笔的使用过程。

![img](https://img2018.cnblogs.com/blog/1475571/201901/1475571-20190112180712208-505786819.png)

实例代码(JAVA):

[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
  1 //抽象类
  2 public abstract class Pen
  3 {
  4     protected Color color;
  5     public void setColor(Color color)
  6     {
  7         this.color=color;
  8     }
  9     public abstract void draw(String name);
 10 } 
 11 
 12 //扩充抽象类
 13 public class SmallPen extends Pen
 14 {
 15     public void draw(String name)
 16     {
 17         String penType="小号毛笔绘制";
 18         this.color.bepaint(penType,name);            
 19     }    
 20 }
 21 
 22 //扩充抽象类
 23 public class MiddlePen extends Pen
 24 {
 25     public void draw(String name)
 26     {
 27         String penType="中号毛笔绘制";
 28         this.color.bepaint(penType,name);            
 29     }    
 30 }
 31 
 32 //扩充抽象类
 33 public class BigPen extends Pen
 34 {
 35     public void draw(String name)
 36     {
 37         String penType="大号毛笔绘制";
 38         this.color.bepaint(penType,name);            
 39     }    
 40 }
 41 
 42 //实现类接口
 43 public interface Color
 44 {
 45     void bepaint(String penType,String name);
 46 }
 47 
 48 //扩充实现类
 49 public class Red implements Color
 50 {
 51     public void bepaint(String penType,String name)
 52     {
 53         System.out.println(penType + "红色的"+ name + ".");
 54     }
 55 }
 56 
 57 //扩充实现类
 58 public class Green implements Color
 59 {
 60     public void bepaint(String penType,String name)
 61     {
 62         System.out.println(penType + "绿色的"+ name + ".");
 63     }
 64 }
 65 
 66 //扩充实现类
 67 public class Blue implements Color
 68 {
 69     public void bepaint(String penType,String name)
 70     {
 71         System.out.println(penType + "蓝色的"+ name + ".");
 72     }
 73 }
 74 
 75 //扩充实现类
 76 public class White implements Color
 77 {
 78     public void bepaint(String penType,String name)
 79     {
 80         System.out.println(penType + "白色的"+ name + ".");
 81     }
 82 }
 83 
 84 //扩充实现类
 85 public class Black implements Color
 86 {
 87     public void bepaint(String penType,String name)
 88     {
 89         System.out.println(penType + "黑色的"+ name + ".");
 90     }
 91 }
 92 
 93 //配置文件configPen.xml
 94 <?xml version="1.0"?>
 95 <config>
 96     <className>Blue</className>
 97     <className>SmallPen</className>
 98 </config>
 99 
100 //使用java反射创建具体的颜色和画笔
101 import javax.xml.parsers.*;
102 import org.w3c.dom.*;
103 import org.xml.sax.SAXException;
104 import java.io.*;
105 public class XMLUtilPen
106 {
107 //该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象
108     public static Object getBean(String args)
109     {
110         try
111         {
112             //创建文档对象
113             DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();
114             DocumentBuilder builder = dFactory.newDocumentBuilder();
115             Document doc;                            
116             doc = builder.parse(new File("configPen.xml")); 
117             NodeList nl=null;
118             Node classNode=null;
119             String cName=null;
120             nl = doc.getElementsByTagName("className");
121             
122             if(args.equals("color"))
123             {
124                 //获取包含类名的文本节点
125                 classNode=nl.item(0).getFirstChild();
126                 
127             }
128             else if(args.equals("pen"))
129             {
130                //获取包含类名的文本节点
131                 classNode=nl.item(1).getFirstChild();
132             }
133             
134              cName=classNode.getNodeValue();
135              //通过类名生成实例对象并将其返回
136              Class c=Class.forName(cName);
137                Object obj=c.newInstance();
138              return obj;        
139            }   
140                catch(Exception e)
141                {
142                    e.printStackTrace();
143                    return null;
144                }
145         }
146 }
147 
148 //客户端
149 public class Client
150 {
151     public static void main(String a[])
152     {
153         Color color;
154         Pen pen;
155         
156         color=(Color)XMLUtilPen.getBean("color");
157         pen=(Pen)XMLUtilPen.getBean("pen");
158         
159         pen.setColor(color);
160         pen.draw("鲜花");
161     }
162 }
```

[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

**实例二：跨平台视频播放器**

  • 如果需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Linux、Unix等）上播放多种格式的视频文件，常见的视频格式包括MPEG、RMVB、AVI、WMV等。现使用桥接模式设计该播放器。

![img](https://img2018.cnblogs.com/blog/1475571/201901/1475571-20190112180801075-628960837.png)

### 模式优缺点

**优点**

  • 分离抽象接口及其实现部分。

  • 桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。

  • 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。

  • 实现细节对客户透明，可以对用户隐藏实现细节。

**缺点**

  • 桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。

  • 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。

### 模式适用环境

在以下情况下可以使用桥接模式：

  • 如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。

  • 抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。

  • 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。

  • 虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。

  • 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。

### 模式应用

  (1) Java语言通过Java虚拟机实现了平台的无关性。

![img](https://img2018.cnblogs.com/blog/1475571/201901/1475571-20190112180825125-69442133.png)

  (2) 一个 Java桌面软件总是带有所在操作系统的视感(LookAndFeel)，如果一个Java软件是在Unix系统上开发的，那么开发人员看到的是Motif用户界面的视感；在Windows上面使用这个系统的用户看到的是Windows用户界面的视感；而一个在Macintosh上面使用的用户看到的则是Macintosh用户界面的视感，Java语言是通过所谓的Peer架构做到这一点的。Java为AWT中的每一个GUI构件都提供了一个Peer构件，在AWT中的Peer架构就使用了桥接模式。

  (3) JDBC驱动程序也是桥接模式的应用之一。使用JDBC驱动程序的应用系统就是抽象角色，而所使用的数据库是实现角色。一个JDBC驱动程序可以动态地将一个特定类型的数据库与一个Java应用程序绑定在一起，从而实现抽象角色与实现角色的动态耦合。

### 模式扩展

**适配器模式与桥接模式的联用**

  • 桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。但有时候在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。

 ![img](https://img2018.cnblogs.com/blog/1475571/201901/1475571-20190112180844018-399078171.png)

## 3.适配器模式

### 1.背景

**适配器模式(Adapter Pattern)**：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。

在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。

根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在**对象适配器模式**中，适配器与适配者之间是**关联**关系；在**类适配器模式**中，适配器与适配者之间是**继承**（或实现）关系。

### 2.角色

**Target（目标抽象类）**：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。

**Adapter（适配器类）**：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。

**Adaptee（适配者类）**：**适配者即被适配的角色**，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。

> 缺省适配器模式(Default Adapter Pattern)：当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。缺省适配器模式是适配器模式的一种变体，其应用也较为广泛。在JDK类库的事件处理包java.awt.event中广泛使用了缺省适配器模式，如WindowAdapter、KeyAdapter、MouseAdapter等。

### 3.示例

#### 类适配器

首先有一个已存在的将被适配的类

```java
public class Adaptee {
    public void adapteeRequest() {
        System.out.println("被适配者的方法");
    }
}
12345
```

定义一个目标接口

```java
public interface Target {
    void request();
}
123
```

怎么才可以在目标接口中的 `request()` 调用 `Adaptee` 的 `adapteeRequest()` 方法呢？

如果直接实现 `Target` 是不行的

```java
public class ConcreteTarget implements Target {
    @Override
    public void request() {
        System.out.println("concreteTarget目标方法");
    }
}
123456
```

如果通过一个适配器类，实现 `Target` 接口，同时继承了 `Adaptee` 类，然后在实现的 `request()` 方法中调用父类的 `adapteeRequest()` 即可实现

```java
public class Adapter extends Adaptee implements Target{
    @Override
    public void request() {
        //...一些操作...
        super.adapteeRequest();
        //...一些操作...
    }
}
12345678
```

我们来测试一下

```java
public class Test {
    public static void main(String[] args) {
        Target target = new ConcreteTarget();
        target.request();

        Target adapterTarget = new Adapter();
        adapterTarget.request();
    }
}
123456789
```

输出

```
concreteTarget目标方法
被适配者的方法
12
```

![类适配器模式类图](https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLmxhaWppYW5mZW5nLm9yZy9QYWNrYWdlJTIwY2xhc3NhZGFwdGVyLnBuZw)

这样我们即可在新接口 `Target` 中适配旧的接口或类

#### 对象适配器

对象适配器与类适配器不同之处在于，类适配器通过继承来完成适配，对象适配器则是通过关联来完成，这里稍微修改一下 `Adapter` 类即可将转变为对象适配器

```java
public class Adapter implements Target{
    // 适配者是对象适配器的一个属性
    private Adaptee adaptee = new Adaptee();

    @Override
    public void request() {
        //...
        adaptee.adapteeRequest();
        //...
    }
}
1234567891011
```

![对象适配器模式类图](https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLmxhaWppYW5mZW5nLm9yZy8yMDE4MDkxOVBhY2thZ2Vfb2JqZWN0YWRhcHRlci5wbmc)

注意这里的 `Adapter` 是将 `Adaptee` 作为一个成员属性，而不是继承它

#### 电压适配器

再来一个好理解的例子，我们国家的民用电都是 220V，日本是 110V，而我们的手机充电一般需要 5V，这时候要充电，就需要一个电压适配器，将 220V 或者 100V 的输入电压变换为 5V 输出

定义输出交流电接口，输出220V交流电类和输出110V交流电类

```java
public interface AC{
 int outputAC();
}

public class AC110 implements AC {
    public final int output = 110;

    @Override
    public int outputAC() {
        return output;
    }
}

public class AC220 implements AC {
    public final int output = 220;

    @Override
    public int outputAC() {
        return output;
    }
}

```

适配器接口，其中 `support()` 方法用于检查输入的电压是否与适配器匹配，`outputDC5V()` 方法则用于将输入的电压变换为 5V 后输出

```java
public interface DC5Adapter {
    boolean support(AC ac);

    int outputDC5V(AC ac);
}
12345
```

实现中国变压适配器和日本变压适配器

```java
public class ChinaPowerAdapter implements DC5Adapter {
    public static final int voltage = 220;
    
    @Override
    public boolean support(AC ac) {
        return (voltage == ac.outputAC());
    }
    
    @Override
    public int outputDC5V(AC ac) {
        int adapterInput = ac.outputAC();
        //变压器...
        int adapterOutput = adapterInput / 44;
        System.out.println("使用ChinaPowerAdapter变压适配器，输入AC:" + adapterInput + "V" + "，输出DC:" + adapterOutput + "V");
        return adapterOutput;
    }
}

public class JapanPowerAdapter implements DC5Adapter {
    public static final int voltage = 110;

    @Override
    public boolean support(AC ac) {
        return (voltage == ac.outputAC());
    }

    @Override
    public int outputDC5V(AC ac) {
        int adapterInput = ac.outputAC();
        //变压器...
        int adapterOutput = adapterInput / 22;
        System.out.println("使用JapanPowerAdapter变压适配器，输入AC:" + adapterInput + "V" + "，输出DC:" + adapterOutput + "V");
        return adapterOutput;
    }
}

```

测试，准备中国变压适配器和日本变压适配器各一个，定义一个方法可以根据电压找到合适的变压器，然后进行测试

```java
public class Test {
    private List<DC5Adapter> adapters = new LinkedList<DC5Adapter>();

    public Test() {
        this.adapters.add(new ChinaPowerAdapter());
        this.adapters.add(new JapanPowerAdapter());
    }

    // 根据电压找合适的变压器
    public DC5Adapter getPowerAdapter(AC ac) {
        DC5Adapter adapter = null;
        for (DC5Adapter ad : this.adapters) {
            if (ad.support(ac)) {
                adapter = ad;
                break;
            }
        }
        if (adapter == null){
            throw new  IllegalArgumentException("没有找到合适的变压适配器");
        }
        return adapter;
    }

    public static void main(String[] args) {
        Test test = new Test();
        AC chinaAC = new AC220();
        DC5Adapter adapter = test.getPowerAdapter(chinaAC);
        adapter.outputDC5V(chinaAC);

        // 去日本旅游，电压是 110V
        AC japanAC = new AC110();
        adapter = test.getPowerAdapter(japanAC);
        adapter.outputDC5V(japanAC);
    }
}

```

输出

```
使用ChinaPowerAdapter变压适配器，输入AC:220V，输出DC:5V
使用JapanPowerAdapter变压适配器，输入AC:110V，输出DC:5V
12
```

### 4.适配器模式总结

**主要优点**：

1. 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。
2. 增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。
3. 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。

具体来说，类适配器模式还有如下优点：

- 由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。

对象适配器模式还有如下优点：

- 一个对象适配器可以把多个不同的适配者适配到同一个目标；
- 可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据“里氏代换原则”，适配者的子类也可通过该适配器进行适配。

类适配器模式的缺点如下：

1. 对于Java、C#等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者；
2. 适配者类不能为最终类，如在Java中不能为final类，C#中不能为sealed类；
3. 在Java、C#等语言中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。

对象适配器模式的缺点如下：

- 与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。

**适用场景**：

- 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。
- 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。

### 5.源码分析适配器模式的典型应用

#### spring AOP中的适配器模式

在Spring的Aop中，使用的 `Advice（通知）` 来增强被代理类的功能。

```
Advice`的类型有：`MethodBeforeAdvice`、`AfterReturningAdvice`、`ThrowsAdvice
```

在每个类型 `Advice` 都有对应的拦截器，`MethodBeforeAdviceInterceptor`、`AfterReturningAdviceInterceptor`、`ThrowsAdviceInterceptor`

Spring需要将每个 `Advice` **都封装成对应的拦截器类型**，返回给容器，所以需要使用适配器模式对 `Advice` 进行转换

三个适配者类 Adaptee 如下：

```java
public interface MethodBeforeAdvice extends BeforeAdvice {
    void before(Method var1, Object[] var2, @Nullable Object var3) throws Throwable;
}

public interface AfterReturningAdvice extends AfterAdvice {
    void afterReturning(@Nullable Object var1, Method var2, Object[] var3, @Nullable Object var4) throws Throwable;
}

public interface ThrowsAdvice extends AfterAdvice {
}
12345678910
```

目标接口 Target，有两个方法，一个判断 `Advice` 类型是否匹配，一个是工厂方法，创建对应类型的 `Advice` 对应的拦截器

```java
public interface AdvisorAdapter {
    boolean supportsAdvice(Advice var1);

    MethodInterceptor getInterceptor(Advisor var1);
}
12345
```

三个适配器类 Adapter 分别如下，注意其中的 Advice、Adapter、Interceptor之间的对应关系

```java
class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable {
	@Override
	public boolean supportsAdvice(Advice advice) {
		return (advice instanceof MethodBeforeAdvice);
	}

	@Override
	public MethodInterceptor getInterceptor(Advisor advisor) {
		MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();
		return new MethodBeforeAdviceInterceptor(advice);
	}
}

@SuppressWarnings("serial")
class AfterReturningAdviceAdapter implements AdvisorAdapter, Serializable {
	@Override
	public boolean supportsAdvice(Advice advice) {
		return (advice instanceof AfterReturningAdvice);
	}
	@Override
	public MethodInterceptor getInterceptor(Advisor advisor) {
		AfterReturningAdvice advice = (AfterReturningAdvice) advisor.getAdvice();
		return new AfterReturningAdviceInterceptor(advice);
	}
}

class ThrowsAdviceAdapter implements AdvisorAdapter, Serializable {
	@Override
	public boolean supportsAdvice(Advice advice) {
		return (advice instanceof ThrowsAdvice);
	}
	@Override
	public MethodInterceptor getInterceptor(Advisor advisor) {
		return new ThrowsAdviceInterceptor(advisor.getAdvice());
	}
}
123456789101112131415161718192021222324252627282930313233343536
```

客户端 DefaultAdvisorAdapterRegistry

```java
public class DefaultAdvisorAdapterRegistry implements AdvisorAdapterRegistry, Serializable {
    private final List<AdvisorAdapter> adapters = new ArrayList(3);

    public DefaultAdvisorAdapterRegistry() {
        // 这里注册了适配器
        this.registerAdvisorAdapter(new MethodBeforeAdviceAdapter());
        this.registerAdvisorAdapter(new AfterReturningAdviceAdapter());
        this.registerAdvisorAdapter(new ThrowsAdviceAdapter());
    }
    
    public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException {
        List<MethodInterceptor> interceptors = new ArrayList(3);
        Advice advice = advisor.getAdvice();
        if (advice instanceof MethodInterceptor) {
            interceptors.add((MethodInterceptor)advice);
        }

        Iterator var4 = this.adapters.iterator();

        while(var4.hasNext()) {
            AdvisorAdapter adapter = (AdvisorAdapter)var4.next();
            if (adapter.supportsAdvice(advice)) {   // 这里调用适配器方法
                interceptors.add(adapter.getInterceptor(advisor));  // 这里调用适配器方法
            }
        }

        if (interceptors.isEmpty()) {
            throw new UnknownAdviceTypeException(advisor.getAdvice());
        } else {
            return (MethodInterceptor[])interceptors.toArray(new MethodInterceptor[0]);
        }
    }
    // ...省略...
}    
12345678910111213141516171819202122232425262728293031323334
```

这里看 while 循环里，逐个取出注册的适配器，调用 `supportsAdvice()` 方法来判断 `Advice` 对应的类型，然后调用 `getInterceptor()` 创建对应类型的拦截器

![spring aop 适配器模式](https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLmxhaWppYW5mZW5nLm9yZy8yMDE4MDkxOV8yMjE3LmpwZw)

这里应该属于对象适配器模式，关键字 `instanceof` 可看成是 `Advice` 的方法，不过这里的 `Advice` 对象是从外部传进来，而不是成员属性

#### spring JPA中的适配器模式

在Spring的ORM包中，对于JPA的支持也是采用了适配器模式，首先定义了一个接口的 `JpaVendorAdapter`，然后不同的持久层框架都实现此接口。

jpaVendorAdapter：用于设置实现厂商JPA实现的特定属性，如设置Hibernate的是否自动生成DDL的属性generateDdl；这些属性是厂商特定的，因此最好在这里设置；目前Spring提供 `HibernateJpaVendorAdapter`、`OpenJpaVendorAdapter`、`EclipseLinkJpaVendorAdapter`、`TopLinkJpaVendorAdapter` 四个实现。其中最重要的属性是 database，用来指定使用的数据库类型，从而能**根据数据库类型来决定比如如何将数据库特定异常转换为Spring的一致性异常**，目前支持如下数据库（DB2、DERBY、H2、HSQL、INFORMIX、MYSQL、ORACLE、POSTGRESQL、SQL_SERVER、SYBASE）

```java
public interface JpaVendorAdapter
{
  // 返回一个具体的持久层提供者
  public abstract PersistenceProvider getPersistenceProvider();

  // 返回持久层提供者的包名
  public abstract String getPersistenceProviderRootPackage();

  // 返回持久层提供者的属性
  public abstract Map<String, ?> getJpaPropertyMap();

  // 返回JpaDialect
  public abstract JpaDialect getJpaDialect();

  // 返回持久层管理器工厂
  public abstract Class<? extends EntityManagerFactory> getEntityManagerFactoryInterface();

  // 返回持久层管理器
  public abstract Class<? extends EntityManager> getEntityManagerInterface();

  // 自定义回调方法
  public abstract void postProcessEntityManagerFactory(EntityManagerFactory paramEntityManagerFactory);
}
1234567891011121314151617181920212223
```

我们来看其中一个适配器实现类 HibernateJpaVendorAdapter

```java
public class HibernateJpaVendorAdapter extends AbstractJpaVendorAdapter {
    //设定持久层提供者
    private final PersistenceProvider persistenceProvider;
    //设定持久层方言
    private final JpaDialect jpaDialect;

    public HibernateJpaVendorAdapter() {
        this.persistenceProvider = new HibernatePersistence();
        this.jpaDialect = new HibernateJpaDialect();
    }

    //返回持久层方言
    public PersistenceProvider getPersistenceProvider() {
        return this.persistenceProvider;
    }

    //返回持久层提供者
    public String getPersistenceProviderRootPackage() {
        return "org.hibernate";
    }

    //返回JPA的属性
    public Map<String, Object> getJpaPropertyMap() {
        Map jpaProperties = new HashMap();

        if (getDatabasePlatform() != null) {
            jpaProperties.put("hibernate.dialect", getDatabasePlatform());
        } else if (getDatabase() != null) {
            Class databaseDialectClass = determineDatabaseDialectClass(getDatabase());
            if (databaseDialectClass != null) {
                jpaProperties.put("hibernate.dialect",
                        databaseDialectClass.getName());
            }
        }

        if (isGenerateDdl()) {
            jpaProperties.put("hibernate.hbm2ddl.auto", "update");
        }
        if (isShowSql()) {
            jpaProperties.put("hibernate.show_sql", "true");
        }

        return jpaProperties;
    }

    //设定数据库
    protected Class determineDatabaseDialectClass(Database database)     
    {                                                                                       
        switch (1.$SwitchMap$org$springframework$orm$jpa$vendor$Database[database.ordinal()]) 
        {                                                                                     
        case 1:                                                                             
          return DB2Dialect.class;                                                            
        case 2:                                                                               
          return DerbyDialect.class;                                                          
        case 3:                                                                               
          return H2Dialect.class;                                                             
        case 4:                                                                               
          return HSQLDialect.class;                                                           
        case 5:                                                                               
          return InformixDialect.class;                                                       
        case 6:                                                                               
          return MySQLDialect.class;                                                          
        case 7:                                                                               
          return Oracle9iDialect.class;                                                       
        case 8:                                                                               
          return PostgreSQLDialect.class;                                                     
        case 9:                                                                               
          return SQLServerDialect.class;                                                      
        case 10:                                                                              
          return SybaseDialect.class; }                                                       
        return null;              
    }

    //返回JPA方言
    public JpaDialect getJpaDialect() {
        return this.jpaDialect;
    }

    //返回JPA实体管理器工厂
    public Class<? extends EntityManagerFactory> getEntityManagerFactoryInterface() {
        return HibernateEntityManagerFactory.class;
    }

    //返回JPA实体管理器
    public Class<? extends EntityManager> getEntityManagerInterface() {
        return HibernateEntityManager.class;
    }
}
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788
```

配置文件中可以这样指定

```java
<bean id="jpaVendorAdapter" class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"> 
   <property name="generateDdl" value="false" />  
   <property name="database" value="HSQL"/>  
</bean>  
<bean id="jpaDialect" class="org.springframework.orm.jpa.vendor.HibernateJpaDialect"/>  
12345
```

#### spring MVC中的适配器模式

Spring MVC中的适配器模式主要用于执行目标 `Controller` 中的请求处理方法。

在Spring MVC中，`DispatcherServlet` 作为用户，`HandlerAdapter` 作为期望接口，具体的适配器实现类用于对目标类进行适配，`Controller` 作为需要适配的类。

为什么要在 Spring MVC 中使用适配器模式？Spring MVC 中的 `Controller` 种类众多，不同类型的 `Controller` 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，`DispatcherServlet` 直接获取对应类型的 `Controller`，需要的自行来判断，像下面这段代码一样：

```java
if(mappedHandler.getHandler() instanceof MultiActionController){  
   ((MultiActionController)mappedHandler.getHandler()).xxx  
}else if(mappedHandler.getHandler() instanceof XXX){  
    ...  
}else if(...){  
   ...  
}  
1234567
```

这样假设如果我们增加一个 `HardController`,就要在代码中加入一行 `if(mappedHandler.getHandler() instanceof HardController)`，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。

我们来看看源码，首先是适配器接口 `HandlerAdapter`

```java
public interface HandlerAdapter {
    boolean supports(Object var1);

    ModelAndView handle(HttpServletRequest var1, HttpServletResponse var2, Object var3) throws Exception;

    long getLastModified(HttpServletRequest var1, Object var2);
}
1234567
```

现该接口的适配器每一个 `Controller` 都有一个适配器与之对应，这样的话，每自定义一个 `Controller` 需要定义一个实现 `HandlerAdapter` 的适配器。

springmvc 中提供的 `Controller` 实现类有如下

![spring mvc Controller 提供的实现类](https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLmxhaWppYW5mZW5nLm9yZy8yMDE4MDkxOV8yMzMzMjcucG5n)

springmvc 中提供的 `HandlerAdapter` 实现类如下

![spring mvc HandlerAdapter 提供的实现类](https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLmxhaWppYW5mZW5nLm9yZy8yMDE4MDkxOV8yMzQzMjUucG5n)

`HttpRequestHandlerAdapter` 这个适配器代码如下

```java
public class HttpRequestHandlerAdapter implements HandlerAdapter {
    public HttpRequestHandlerAdapter() {
    }

    public boolean supports(Object handler) {
        return handler instanceof HttpRequestHandler;
    }

    public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        ((HttpRequestHandler)handler).handleRequest(request, response);
        return null;
    }

    public long getLastModified(HttpServletRequest request, Object handler) {
        return handler instanceof LastModified ? ((LastModified)handler).getLastModified(request) : -1L;
    }
}
1234567891011121314151617
```

当Spring容器启动后，会将所有定义好的适配器对象存放在一个List集合中，当一个请求来临时，`DispatcherServlet` 会通过 `handler` 的类型找到对应适配器，并将该适配器对象返回给用户，然后就可以统一通过适配器的 `hanle()` 方法来调用 `Controller` 中的用于处理请求的方法。

```java
public class DispatcherServlet extends FrameworkServlet {
    private List<HandlerAdapter> handlerAdapters;
    
    //初始化handlerAdapters
    private void initHandlerAdapters(ApplicationContext context) {
        //..省略...
    }
    
    // 遍历所有的 HandlerAdapters，通过 supports 判断找到匹配的适配器
    protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {
		for (HandlerAdapter ha : this.handlerAdapters) {
			if (logger.isTraceEnabled()) {
				logger.trace("Testing handler adapter [" + ha + "]");
			}
			if (ha.supports(handler)) {
				return ha;
			}
		}
	}
	
	// 分发请求，请求需要找到匹配的适配器来处理
	protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
		HttpServletRequest processedRequest = request;
		HandlerExecutionChain mappedHandler = null;

		// Determine handler for the current request.
		mappedHandler = getHandler(processedRequest);
			
		// 确定当前请求的匹配的适配器.
		HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

		ha.getLastModified(request, mappedHandler.getHandler());
					
		mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
    }
	// ...省略...
}	
12345678910111213141516171819202122232425262728293031323334353637
```

通过适配器模式我们将所有的 `controller` 统一交给 `HandlerAdapter` 处理，免去了写大量的 `if-else` 语句对 `Controller` 进行判断，也更利于扩展新的 `Controller` 类型。

## 4.代理模式

### Java的三种代理模式

#### 1.1.代理模式

代理(Proxy)是一种设计模式,提供了对目标对象另外的访问方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能.
这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法

举个例子来说明代理的作用:假设我们想邀请一位明星,那么并不是直接连接明星,而是联系明星的经纪人,来达到同样的目的.明星就是一个目标对象,他只要负责活动中的节目,而其他琐碎的事情就交给他的代理人(经纪人)来解决.这就是代理思想在现实中的一个例子

用图表示如下:

![img](https://images2015.cnblogs.com/blog/790334/201701/790334-20170116124522880-1137330008.png)

代理模式的关键点是:代理对象与目标对象.代理对象是对目标对象的扩展,并会调用目标对象

#### 1.2.静态代理

静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类.

下面举个案例来解释:
模拟保存动作,定义一个保存动作的接口:IUserDao.java,然后目标对象实现这个接口的方法UserDao.java,此时如果使用静态代理方式,就需要在代理对象(UserDaoProxy.java)中也实现IUserDao接口.调用的时候通过调用代理对象的方法来调用目标对象.
需要注意的是,代理对象与目标对象要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法

代码示例:
接口:IUserDao.java

```

```

[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 * 接口
 */
public interface IUserDao {

    void save();
}
```

[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```

```

 

目标对象:UserDao.java

[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 * 接口实现
 * 目标对象
 */
public class UserDao implements IUserDao {
    public void save() {
        System.out.println("----已经保存数据!----");
    }
}
```

[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

代理对象:UserDaoProxy.java

[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 * 代理对象,静态代理
 */
public class UserDaoProxy implements IUserDao{
    //接收保存目标对象
    private IUserDao target;
    public UserDaoProxy(IUserDao target){
        this.target=target;
    }

    public void save() {
        System.out.println("开始事务...");
        target.save();//执行目标对象的方法
        System.out.println("提交事务...");
    }
}
```

[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

测试类:App.java

[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 * 测试类
 */
public class App {
    public static void main(String[] args) {
        //目标对象
        UserDao target = new UserDao();

        //代理对象,把目标对象传给代理对象,建立代理关系
        UserDaoProxy proxy = new UserDaoProxy(target);

        proxy.save();//执行的是代理的方法
    }
}
```

[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

```
 
```

**静态代理总结:**
1.可以做到在不修改目标对象的功能前提下,对目标功能扩展.
2.缺点:

- 因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护.

如何解决静态代理中的缺点呢?答案是可以使用动态代理方式

#### 1.3.动态代理

**动态代理有以下特点:**
1.代理对象,不需要实现接口
2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)
3.动态代理也叫做:JDK代理,接口代理

**JDK中生成代理对象的API**
代理类所在包:java.lang.reflect.Proxy
JDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数,完整的写法是:

```
static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,InvocationHandler h )
```

注意该方法是在Proxy类中是静态方法,且接收的三个参数依次为:

- `ClassLoader loader,`:指定当前目标对象使用类加载器,获取加载器的方法是固定的
- `Class[] interfaces,`:目标对象实现的接口的类型,使用泛型方式确认类型
- `InvocationHandler h`:事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入

代码示例:
接口类IUserDao.java以及接口实现类,目标对象UserDao是一样的,没有做修改.在这个基础上,增加一个代理工厂类(ProxyFactory.java),将代理类写在这个地方,然后在测试类(需要使用到代理的代码)中先建立目标对象和代理对象的联系,然后代用代理对象的中同名方法

代理工厂类:ProxyFactory.java

```
/**
 * 创建动态代理对象
 * 动态代理不需要实现接口,但是需要指定接口类型
 */
```

[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
public class ProxyFactory{

    //维护一个目标对象
    private Object target;
    public ProxyFactory(Object target){
        this.target=target;
    }

   //给目标对象生成代理对象
    public Object getProxyInstance(){
        return Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                new InvocationHandler() {
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println("开始事务2");
                        //执行目标对象方法
                        Object returnValue = method.invoke(target, args);
                        System.out.println("提交事务2");
                        return returnValue;
                    }
                }
        );
    }

}
```

[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

测试类:App.java

[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 * 测试类
 */
public class App {
    public static void main(String[] args) {
        // 目标对象
        IUserDao target = new UserDao();
        // 【原始的类型 class cn.itcast.b_dynamic.UserDao】
        System.out.println(target.getClass());

        // 给目标对象，创建代理对象
        IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance();
        // class $Proxy0   内存中动态生成的代理对象
        System.out.println(proxy.getClass());

        // 执行方法   【代理对象】
        proxy.save();
    }
}
```

[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

**总结:**
代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能用动态代理

#### 1.4.Cglib代理

上面的静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用以目标对象子类的方式类实现代理,这种方法就叫做:Cglib代理

Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.

- JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现.
- Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)
- Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉.

Cglib子类代理实现方法:
1.需要引入cglib的jar文件,但是Spring的核心包中已经包括了Cglib功能,所以直接引入`pring-core-3.2.5.jar`即可.
2.引入功能包后,就可以在内存中动态构建子类
3.代理的类不能为final,否则报错
4.目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法.

代码示例:
目标对象类:UserDao.java

[![复制代码](https:////common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 * 目标对象,没有实现任何接口
 */
public class UserDao {

    public void save() {
        System.out.println("----已经保存数据!----");
    }
}
```



 

Cglib代理工厂:ProxyFactory.java

```
/**
 * Cglib子类代理工厂
 * 对UserDao在内存中动态构建一个子类对象
 */
public class ProxyFactory implements MethodInterceptor{
    //维护目标对象
    private Object target;

    public ProxyFactory(Object target) {
        this.target = target;
    }

    //给目标对象创建一个代理对象
    public Object getProxyInstance(){
        //1.工具类
        Enhancer en = new Enhancer();
        //2.设置父类
        en.setSuperclass(target.getClass());
        //3.设置回调函数
        en.setCallback(this);
        //4.创建子类(代理对象)
        return en.create();

    }

    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println("开始事务...");

        //执行目标对象的方法
        Object returnValue = method.invoke(target, args);

        System.out.println("提交事务...");

        return returnValue;
    }
}
```

 

测试类:

```
/**
 * 测试类
 */
public class App {

    @Test
    public void test(){
        //目标对象
        UserDao target = new UserDao();

        //代理对象
        UserDao proxy = (UserDao)new ProxyFactory(target).getProxyInstance();

        //执行代理对象的方法
        proxy.save();
    }
}
```





######                                      **谢谢**